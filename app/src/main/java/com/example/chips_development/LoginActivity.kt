package com.example.chips_development

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.View
import android.widget.Button
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast
import com.example.chips_development.adapters.ShopsAdapter
import org.json.JSONArray
import java.io.*

class LoginActivity : AppCompatActivity() {

//    private var prefs: SharedPreferences? = null

    private var login: EditText? = null
    private var password: EditText? = null
    private var btLogin: Button? = null
    private var btCreateUser: Button? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)

//        prefs = getSharedPreferences("com.example.chips_development", MODE_PRIVATE)

//        login = findViewById(R.id.login)
//        password = findViewById(R.id.password)

        btLogin = findViewById(R.id.btLogin)
        btLogin?.setOnClickListener(onClickListener)
        btCreateUser = findViewById(R.id.btCreateUser)
        btCreateUser?.setOnClickListener(onClickListener)

        val jsonString = readFromFile(applicationContext)
        val jsonArray = JSONArray(jsonString)

        for (i in 0 until jsonArray.length()) {
            val jsonObj = jsonArray.getJSONObject(i)

            val jsStatus = jsonObj.getString("status")
            if (jsStatus == "true") {
                Handler(Looper.getMainLooper()).postDelayed({
                    val intent = Intent(this, CourseActivity::class.java)
                    startActivity(intent)
                    finish()
                }, 1)
            }
        }
    }

    private val onClickListener: View.OnClickListener = View.OnClickListener {
        when (it.id) {
            R.id.btLogin -> {
                val jsonString = readFromFile(context = applicationContext)
                val jsonArray = JSONArray(jsonString)
                var writableString = ""
                login = findViewById(R.id.login)
                val log = login?.text.toString()
                password = findViewById(R.id.password)
                val pas = password?.text.toString()

                for (i in 0 until jsonArray.length()) {
                    val jsonObj = jsonArray.getJSONObject(i)

                    val jsLogin = jsonObj.getString("login")
                    val jsPassword = jsonObj.getString("password")
//                    val jsStatus = jsonObj.getString("status")
                    val jsFile = jsonObj.getString("file")
                    if (log != jsLogin || pas != jsPassword) {
                        login?.text?.clear()
                        password?.text?.clear()
//                        Toast.makeText(applicationContext, "Неверный пароль!", Toast.LENGTH_SHORT).show()
                        writableString += jsonObj.toString()
                    }
                    else if (log != jsLogin) {
                        login?.text?.clear()
                        password?.text?.clear()
//                        Toast.makeText(applicationContext, "Данного пользователя не существует!", Toast.LENGTH_SHORT).show()
                        writableString += jsonObj.toString()
                    }
                    else if (log == jsLogin && pas == jsPassword) {
                        var preResultIfCurrent = jsonObj.toString().replace(
                            "\"status\":\"false\"",
                            "\"status\":\"true\"",
                            true
                        )

                        if (jsFile == "false") {
                            writeFilesForCurUser(log)

                            preResultIfCurrent = preResultIfCurrent.replace(
                                "\"file\":\"false\"",
                                "\"file\":\"true\"",
                                true
                            )
                        }
                        writableString += preResultIfCurrent
                    }
                }

                val preResult = writableString.replace(
                    "\"}{\"",
                    "\"},{\"",
                    true
                )
                val result = "[$preResult]"

                writeFileOnInternalStorage(file = "users.json", data = result, context = applicationContext)

                Handler(Looper.getMainLooper()).postDelayed({
                    val intent = Intent(this, CourseActivity::class.java)
                    startActivity(intent)
                    finish()
                }, 100)
            }
            R.id.btCreateUser -> {
                Handler(Looper.getMainLooper()).postDelayed({
                    val intent = Intent(this, CreateUserActivity::class.java)
                    startActivity(intent)
                    finish()
                }, 100)
            }
        }
    }

//    override fun onResume() {
//        super.onResume()
//        if (prefs!!.getBoolean("firstrun", true)) {
//            // Do first run stuff here then set 'firstrun' as false
//            // using the following line to edit/commit prefs
//            prefs!!.edit().putBoolean("firstrun", false).commit()
//
//            writeFileOnInternalStorage(file = "users.json", data = "[\n" +
//                    "  {\n" +
//                    "    \"file\": \"false\",\n" +
//                    "    \"status\": \"false\",\n" +
//                    "    \"login\": \"root\",\n" +
//                    "    \"password\": \"toor\"\n" +
//                    "  }\n" +
//                    "]", context = applicationContext)
//
//            writeFileOnInternalStorage(file = "shops.json", data = "[\n" +
//                    "  {\n" +
//                    "    \"name\": \"name1\",\n" +
//                    "    \"link\": \"https://www.chipdip.ru/\",\n" +
//                    "    \"image\": \"https://s.rbk.ru/v1_companies_s3/resized/550xH/media/trademarks/86b2d8ca-8c46-4d25-a8e8-3336c7ade6f1.jpg\"\n" +
//                    "  },\n" +
//                    "  {\n" +
//                    "    \"name\": \"name2\",\n" +
//                    "    \"link\": \"https://stackoverflow.com/questions/2201917/how-can-i-open-a-url-in-androids-web-browser-from-my-application\",\n" +
//                    "    \"image\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
//                    "  }\n" +
//                    "]", context = applicationContext)
//        }
//    }

    private fun writeFileOnInternalStorage(file:String, data:String, context: Context) {
        val fOut: FileOutputStream = context.openFileOutput(file, MODE_PRIVATE
        )
        fOut.write(data.toByteArray())
        fOut.close()
    }

    private fun readFromFile(context: Context): String {
        var ret = ""
        var inputStream: InputStream? = null
        try {
            inputStream = context.openFileInput("users.json")
            if (inputStream != null) {
                val inputStreamReader = InputStreamReader(inputStream)
                val bufferedReader = BufferedReader(inputStreamReader)
                var receiveString: String? = ""
                val stringBuilder = StringBuilder()
                while (bufferedReader.readLine().also { receiveString = it } != null) {
                    stringBuilder.append(receiveString)
                }
                ret = stringBuilder.toString()
            }
        } catch (e: FileNotFoundException) {
            Log.e("login activity", "File not found: " + e.toString())
        } catch (e: IOException) {
            Log.e("login activity", "Can not read file: $e")
        } finally {
            try {
                inputStream!!.close()
            } catch (e: IOException) {
                e.printStackTrace()
            }
        }
        return ret
    }

    private fun writeFilesForCurUser(log: String) {
        val fileNameTest = log + "test.json"
        writeFileOnInternalStorage(
            file = fileNameTest, data = "[\n" +
                    "  {\n" +
                    "    \"status\": \"false\",\n" +
                    "    \"theme_name\": \"Введение\",\n" +
                    "    \"question1\": \"Информация - это:\",\n" +
                    "    \"status_question1\": \"false\",\n" +
                    "    \"var1_question1\": \"Совокупность сведений, знаний, которые актуализируемы (получаемы, передаваемы, преобразуемы, сжимаемы и/или регистрируемы) с помощью некоторых знаков.\",\n" +
                    "    \"status_var1_question1\": \"true\",\n" +
                    "    \"var2_question1\": \"Точный набор инструкций, описывающих последовательность действий некоторого исполнителя.\",\n" +
                    "    \"status_var2_question1\": \"false\",\n" +
                    "    \"var3_question1\": \"Поток данных подсистемы МК\",\n" +
                    "    \"status_var3_question1\": \"false\",\n" +
                    "    \"var4_question1\": \"Знания относительно фактов, событий, вещей, идей и понятий, которые в определённом контексте имеют конкретный смысл.\",\n" +
                    "    \"status_var4_question1\": \"false\",\n" +
                    "    \"question2\": \"Алгоритм – это:\",\n" +
                    "    \"status_question2\": \"false\",\n" +
                    "    \"var1_question2\": \"Сведения независимо от формы их представления.\",\n" +
                    "    \"status_var1_question2\": \"false\",\n" +
                    "    \"var2_question2\": \"Это точный набор инструкций, описывающих последовательность действий некоторого исполнителя для достижения результата, решения некоторой задачи.\",\n" +
                    "    \"status_var2_question2\": \"true\",\n" +
                    "    \"var3_question2\": \"Линия приема и передачи данных.\",\n" +
                    "    \"status_var3_question2\": \"false\",\n" +
                    "    \"var4_question2\": \"Это точная, однозначная, конечная последовательность вычислений для решения конкретной задачи или группы задач за конечное число шагов.\",\n" +
                    "    \"status_var4_question2\": \"false\",\n" +
                    "    \"question3\": \"К общим признакам встраиваемых микроконтроллеров можно отнести:\",\n" +
                    "    \"status_question3\": \"false\",\n" +
                    "    \"var1_question3\": \"Компактные размеры и наличие радиаторов для эффективного отвода тепла.\",\n" +
                    "    \"status_var1_question3\": \"false\",\n" +
                    "    \"var2_question3\": \"Ортогональность внутренних регистров микроконтроллера, позволяющую оптимизировать структуру программы.\",\n" +
                    "    \"status_var2_question3\": \"false\",\n" +
                    "    \"var3_question3\": \"Все необходимые ресурсы (память, устройства ввода-вывода и т.д.) располагаются на одном кристалле с процессорным ядром.\",\n" +
                    "    \"status_var3_question3\": \"true\",\n" +
                    "    \"var4_question3\": \"Такой микроконтроллер имеет архитектуру, облегчающую работу с вещественными числами.\",\n" +
                    "    \"status_var4_question3\": \"false\",\n" +
                    "    \"question4\": \"В состав встраиваемых микроконтроллеров обычно входят:\",\n" +
                    "    \"status_question4\": \"false\",\n" +
                    "    \"var1_question4\": \"Устройства индикации и средства ручной подстройки тактовой частоты.\",\n" +
                    "    \"status_var1_question4\": \"false\",\n" +
                    "    \"var2_question4\": \"Контроллеры блока питания.\",\n" +
                    "    \"status_var2_question4\": \"false\",\n" +
                    "    \"var3_question4\": \"Декодеры сигналов, преобразующие полутороразрядный код в ШИМ сигнал.\",\n" +
                    "    \"status_var3_question4\": \"false\",\n" +
                    "    \"var4_question4\": \"Средства ввода-вывода данных и таймеры, фиксирующие число командных циклов.\",\n" +
                    "    \"status_var4_question4\": \"true\",\n" +
                    "    \"question5\": \"Типичным примером микроконтроллера с внешней памятью является:\",\n" +
                    "    \"status_question5\": \"false\",\n" +
                    "    \"var1_question5\": \"Контроллер жесткого диска.\",\n" +
                    "    \"status_var1_question5\": \"true\",\n" +
                    "    \"var2_question5\": \"Контроллер управления прерываниями.\",\n" +
                    "    \"status_var2_question5\": \"false\",\n" +
                    "    \"var3_question5\": \"Контроллер блока питания.\",\n" +
                    "    \"status_var3_question5\": \"false\",\n" +
                    "    \"var4_question5\": \"Контроллер клавиатуры.\",\n" +
                    "    \"status_var4_question5\": \"false\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"status\": \"false\",\n" +
                    "    \"theme_name\": \"Основы вычислительной техники. ТТЛ-логика\",\n" +
                    "    \"question1\": \"Микропроцессорная система какого типа не обеспечивает управление внешними устройствами?\",\n" +
                    "    \"status_question1\": \"true\",\n" +
                    "    \"var1_question1\": \"Компьютер.\",\n" +
                    "    \"status_var1_question1\": \"false\",\n" +
                    "    \"var2_question1\": \"Все типы обеспечивают управление внешними устройствами.\",\n" +
                    "    \"status_var2_question1\": \"true\",\n" +
                    "    \"var3_question1\": \"Микроконтроллер.\",\n" +
                    "    \"status_var3_question1\": \"false\",\n" +
                    "    \"var4_question1\": \"Контроллер.\",\n" +
                    "    \"status_var4_question1\": \"false\",\n" +
                    "    \"question2\": \"Какая структура шин адреса и данных обеспечивает большее быстродействие?\",\n" +
                    "    \"status_question2\": \"false\",\n" +
                    "    \"var1_question2\": \"Быстродействие от структуры не зависит.\",\n" +
                    "    \"status_var1_question2\": \"false\",\n" +
                    "    \"var2_question2\": \"Двунаправленная.\",\n" +
                    "    \"status_var2_question2\": \"false\",\n" +
                    "    \"var3_question2\": \"Немультиплексированная.\",\n" +
                    "    \"status_var3_question2\": \"true\",\n" +
                    "    \"var4_question2\": \"Мультиплексированная.\",\n" +
                    "    \"status_var4_question2\": \"false\",\n" +
                    "    \"question3\": \"К какой группе относятся команды сдвига кодов?\",\n" +
                    "    \"status_question3\": \"false\",\n" +
                    "    \"var1_question3\": \"Команды переходов.\",\n" +
                    "    \"status_var1_question3\": \"false\",\n" +
                    "    \"var2_question3\": \"Команды пересылки.\",\n" +
                    "    \"status_var2_question3\": \"false\",\n" +
                    "    \"var3_question3\": \"Арифметические команды.\",\n" +
                    "    \"status_var3_question3\": \"false\",\n" +
                    "    \"var4_question3\": \"Логические команды.\",\n" +
                    "    \"status_var4_question3\": \"true\",\n" +
                    "    \"question4\": \"Какой тип логической функции позволяет реализовать объединение «квазидвунаправленных» выходов микроконтроллера?\",\n" +
                    "    \"status_question4\": \"false\",\n" +
                    "    \"var1_question4\": \"«И«\",\n" +
                    "    \"status_var1_question4\": \"true\",\n" +
                    "    \"var2_question4\": \"Сложение по модулю 2\",\n" +
                    "    \"status_var2_question4\": \"false\",\n" +
                    "    \"var3_question4\": \"«ИЛИ«\",\n" +
                    "    \"status_var3_question4\": \"false\",\n" +
                    "    \"var4_question4\": \"Константа «1«\",\n" +
                    "    \"status_var4_question4\": \"false\",\n" +
                    "    \"question5\": \"Выберите неверное утверждение:\",\n" +
                    "    \"status_question5\": \"false\",\n" +
                    "    \"var1_question5\": \"PCI — быстродействующая шина.\",\n" +
                    "    \"status_var1_question5\": \"false\",\n" +
                    "    \"var2_question5\": \"PCI — немультиплексированная шина.\",\n" +
                    "    \"status_var2_question5\": \"true\",\n" +
                    "    \"var3_question5\": \"На шине PCI возможен синхронный и асинхронный обмен.\",\n" +
                    "    \"status_var3_question5\": \"false\",\n" +
                    "    \"var4_question5\": \"На шине PCI предусмотрена автоконфигурация.\",\n" +
                    "    \"status_var4_question5\": \"false\"\n" +
                    "  }\n" +
                    "]", context = applicationContext
        )
        val fileNameStudy = log + "study.json"
        writeFileOnInternalStorage(
            file = fileNameStudy, data = "[\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Введение\",\n" +
                    "    \"themes\": \"История вычислительной техники. Обзор современных платформ и их приложений\",\n" +
                    "    \"lessonTextStart\": \"\\tСовременному человеку трудно представить свою жизнь без электронно- вычислительных машин. Влияние вычислительной техники на все сферы деятельности человека продолжает расширяться вширь и вглубь. В настоящее время ЭВМ используются не только для выполнения сложных расчетов, но и в управлении производственными процессами, в образовании, здравоохранении, экологии и т.д. Это объясняется тем, что ЭВМ способны обрабатывать любые виды информации: числовую, текстовую, табличную, графическую, видео, звуковую.\\n\\tИдея использования программного управления для построения устройства, автоматически выполняющего арифметические вычисления, была впервые высказана английским математиком Чарльзом Бэббиджем в1833г. Он начал работать над машиной для вычисления полиномов, но эта машина должна была кроме непосредственного производства вычислений выдавать результаты– печатать их на негативной пластине для фотопечати. Планировалось, что машина будет приводиться в действие паровым двигателем. Но из-за технических трудностей Бэббиджу до конца не удалось реализовать свой проект.\\n\\tВ современном представлении электронная вычислительная машина– это комплекс технических и программных средств для проведения вычислений, а также приёма, переработки, хранения и выдачи информации по заранее определённому алгоритму (компьютерной программе).\\n\\tИнформация – совокупность сведений, знаний, которые актуализируемы (получаемы, передаваемы, преобразуемы, сжимаемы и/или регистрируемы) с помощью некоторых знаков.\\n\\tАлгоритм – это точный набор инструкций, описывающих последовательность действий некоторого исполнителя для достижения результата, решения некоторой задачи.\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"\\tИсторию развития вычислительных машин принято делить на поколения\\n\\t1-е поколение (1945-1954 гг.) — время становления машин с фон-неймановской архитектурой. В этот период формируется типовой набор структурных элементов, входящих в состав ЭВМ. Типичная ЭВМ должна состоять из следующих узлов: центральный процессор(ЦП), оперативная память (или оперативное запоминающее устройство— ОЗУ) и устройства ввода-вывода(УВВ). ЦП, в свою очередь, должен состоять из арифметико-логического устройства(АЛУ) и управляющего устройства(УУ). Машины этого поколения работали на ламповой элементной базе, из-за чего поглощали огромное количество энергии и были очень ненадежны. С их помощью, в основном, решались научные задачи. Программы для этих машин уже можно было составлять не на машинном языке, а на языке ассемблера.\\n\\t2-е поколение (1955-1964 гг.). Смену поколений определило появление новой элементной базы: вместо громоздкой лампы в ЭВМ стали применяться миниатюрные транзисторы, линии задержки как элементы оперативной памяти сменила память на магнитных сердечниках. Это в конечном итоге привело к уменьшению габаритов, повышению надежности и производительности ЭВМ. В архитектуре ЭВМ появились индексные регистры и аппаратные средства для выполнения операций с плавающей точкой. Были разработаны команды для вызова подпрограмм. Появились языки высокого уровня— Algol, FORTRAN, COBOL, — создавшие предпосылки для появления переносимого программного обеспечения, не зависящего от типа ЭВМ. С появлением языков высокого уровня возникли компиляторы для них; библиотеки стандартных подпрограмм и другие хорошо знакомые нам сейчас вещи: Важное новшество— это появление процессоров ввода-вывода. Эти специализированные процессоры позволили освободить ЦП от управления вводом-выводом и осуществлять ввод-вывод с помощью специализированного устройства одновременно с процессом вычислений. Для эффективного управления ресурсами машины стали использоваться операционные системы(ОС).\\n\\t3-е поколение (1965-1970 гг.). Микросхемы позволили разместить десятки элементов на пластине размером в несколько сантиметров. Это, в свою очередь, не только повысило производительность ЭВМ, но и снизило их габариты и стоимость. Увеличение мощности ЭВМ сделало возможным одновременное выполнение нескольких программ на одной ЭВМ. Для этого нужно было научиться координировать между собой одновременно выполняемые действия, для чего были расширены функции операционной системы. Одновременно с активными разработками в области аппаратных и архитектурных решений растет удельный вес разработок в области технологий программирования. В это время активно разрабатываются теоретические основы методов программирования, компиляции, баз данных, операционных систем и т. д. Создаются пакеты прикладных программ для самых различных областей жизнедеятельности человека. Наблюдается тенденция к созданию семейств ЭВМ, то есть машины становятся совместимы снизу в верх на программно-аппаратном уровне. Примерами таких семейств была серия IBM System 360 и наш отечественный аналог- ЕС ЭВМ.\\n\\t4-е поколение (1970-1984 гг.). Очередная смена элементной базы привела к смене поколений. В70-егоды активно ведутся работы по созданию больших и сверхбольших интегральных схем (БИС и СБИС), которые позволили разместить на одном кристалле десятки тысяч элементов. Это повлекло дальнейшее существенное снижение размеров и стоимости ЭВМ. В начале70-хгодов фирмойIntel был выпущен микропроцессор(МП) i4004. И если до этого в мире вычислительной техники были только три направления (суперЭВМ, большие ЭВМ (мэйнфреймы) имини-ЭВМ), то теперь к ним прибавилось еще одно— микропроцессорное.\\n\\t5-е поколение можно назвать микропроцессорным. В1976 году фирма Intel закончила разработку16-разрядногомикропроцессораi8086. Он имел достаточно большую разрядность регистров (16 бит) и системной шины адреса (20 бит), за счет чего мог адресовать до1 Мбайт оперативной памяти. В1982 году был созданi80286. Этот микропроцессор представлял собой улучшенный вариантi8086. Он поддерживал уже несколько режимов работы: реальный, когда формирование адреса производилось по правиламi8086, и защищенный, который аппаратно реализовывал многозадачность и управление виртуальной памятью, i80286 имел также большую разрядность шины адреса— 24 разряда против, 20 уi8086, и поэтому он мог адресовать до16 Мбайт оперативной памяти. Первые компьютеры на базе этого микропроцессора появились в1984 году. В1985 году фирма Intel представила первый32-разрядныймикропроцессорi80386, аппаратно совместимый снизу-вверх со всеми предыдущими микропроцессорами этой фирмы. Он был гораздо мощнее своих предшественников, имел32-разряднуюархитектуру и мог прямо адресовать до 4 Гбайт оперативной памяти. Микропроцессорi386 стал поддерживать новый режим работы— режим виртуальногоi8086, который обеспечил не только большую эффективность работу программ, разработанных дляi8086, но и позволил осуществлять параллельную работу нескольких таких программ.\",\n" +
                    "    \"lessonImageMid\": \"https://i.postimg.cc/sX9Ccn2Y/2022-11-22-224055.png\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Основы вычислительной техники. ТТЛ-логика\",\n" +
                    "    \"themes\": \"Обзор архитектурных решений для создания вычислительных устройств\",\n" +
                    "    \"lessonTextStart\": \"\\tТранзисторно-транзисторная логика (ТТЛ, TTL) — разновидность цифровых логических микросхем, построенных на основе биполярных транзисторов и резисторов. Название транзисторно-транзисторный возникло из-за того, что транзисторы используются как для выполнения логических функций (например, И, ИЛИ), так и для усиления выходного сигнала (в отличие от резисторно-транзисторной и диодно-транзисторной логики).\\n\\tВажность ТТЛ заключается в том, что ТТЛ-микросхемы оказались более пригодны для массового производства и при этом превосходили по параметрам ранее выпускавшиеся серии микросхем (резисторно-транзисторная и диодно-транзисторная логика).\\n\\tСамая простая модель транзистора может быть представлена как объединение двух диодов. Соответственно, в зависимости от полярности включения диодов можно получить два типа транзисторов — NPN и PNP.\\n\\tКак и триод, транзистор может использоваться как усилитель тока. Ток, который протекает между коллектором и эмиттером, зависит от тока, идущего через базу и эмиттер. Направление тока определяется типом перехода транзистора. Важно отметить, что зависимость между вышеуказанными токами нелинейная, что позволяет делать достаточно сложные схемы. В задании к данному разделу вам будет предложена схема симуляции простого логического элемента на транзисторе, в которой вы можете попробовать собрать свои схемы.\\n\\tСуществуют различные объяснения принципов работы полупроводниковых элементов, например водопроводная аналогия, которые хорошо иллюстрируют принцип работы транзистора. Если вы хотите досконально разобраться в работе транзистора, рекомендуем изучить вторую главу книги П. Хоровица, У. Хилла «Искусство схемотехники».\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"\\t1. Классическая архитектура (архитектура фон Неймана) – одно арифметико-логическое устройство (АЛУ), через которое проходит поток данных, и одно устройство управления (УУ), через которое проходит поток команд – программа. Это однопроцессорный компьютер.\\n\\t2. Многопроцессорная архитектура. Наличие в компьютере нескольких процессоров означает, что параллельно может быть организовано много потоков данных и много потоков команд. Таким образом, параллельно могут выполняться несколько фрагментов одной задачи. Структура такой машины, имеющей общую оперативную память и несколько процессоров.\\n\\t3. Многомашинная вычислительная система. Здесь несколько процессоров, входящих в вычислительную систему, не имеют общей оперативной памяти, а имеют каждый свою (локальную). Каждый компьютер в многомашинной системе имеет классическую архитектуру, и такая система применяется достаточно широко. Однако эффект от применения такой вычислительной системы может быть получен только при решении задач, имеющих очень специальную структуру: она должна разбиваться на столько слабо связанных подзадач, сколько компьютеров в системе.\\n\\t4. Архитектура с параллельными процессорами. Здесь несколько АЛУ работают под управлением одного УУ. Это означает, что множество данных может обрабатываться по одной программе – то есть по одному потоку команд. Высокое быстродействие такой архитектуры можно получить только на задачах, в которых одинаковые вычислительные операции выполняются одновременно на различных однотипных наборах данных.\\n\\tСуществующие в настоящее время многопроцессорные системы можно разделить на два класса: универсальные и проблемно-ориентированные. Проблемно-ориентированные системы могут эффективно решать одну-единственную задачу, для которой они созданы. Универсальные многопроцессорные системы могут решать любую задачу, но при этом их производительность существенно ниже пиковой.\\n\\tДля создания вычислительных систем с программируемой архитектурой и массовым параллелизмом на основе отечественной элементной базы предлагается использовать метод структурно-процедурной организации вычислений. В этом методе поток команд распределяется (распараллеливается) по исполнительным устройствам, образуя в структуре системы аппаратно-реализуемые фрагменты вычислительного процесса (кадры). Полный информационный граф задачи разбивается на фрагменты (подграфы), которые последовательно проецируются в структуру системы и реализуются аппаратно (структурно).\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Вычислительное ядро. Организация памяти\",\n" +
                    "    \"themes\": \"Описание «нулевого» функционала ЭВМ. Принципы хранения и исполнения программ\",\n" +
                    "    \"lessonTextStart\": \"\\tЯдро Cortex-M3 — одно из наиболее популярных среди МК STM32. На этом уровне важны три ключевых компонента:\\n\\t-Ядро (CM3Core)\\n\\t-Контроллер вложенных прерываний (NVIC)\\n\\t-Шинная матрица (Bus Matrix)\\n\\t-ОЗУ используется для хранения промежуточных данных во время работы МК, например пользовательских переменных.\\n\\tКонтроллер вложенных прерываний нужен, как подсказывает логика, для отработки прерываний — событий, требующих быстрой обработки. Важно помнить, что у ядра конечное число потоков, которые он может обслуживать единовременно, именно поэтому для обработки «быстрых» событий может потребоваться приостановка процессов основной программы. В свою очередь, прерывания могут быть прерваны другими с более высоким приоритетом. Для обработки и настройки приоритетов для подобных случаев контроллер вложенных прерываний обладает несколькими каналами обработки прерываний.\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"\\tПринцип действия ЭВМ\\n\\tБольшинство современных ЭВМ строится на базе принципов, сформулированных американским ученым, одним из отцов кибернетики Дж. Фон Нейманом. В целом эти принципы сводятся к следующему:\\n\\t-Основными блоками фон-неймановской машины являются: блок управления, АЛУ (арифметическо - логическое устройство), память, устройства ввода-вывода;\\n\\t-Информация кодируется в двоичной форме и разделяется на единицы, называемые словами;\\n\\t-Алгоритм представляется в форме последовательности управляющих слов, которые определяют смысл операции. Эти управляющие слова называются командами. Совокупность команд, представляющая алгоритм, называется программой;\\n\\t-Программы и данные хранятся в одной и той же памяти. Разнотипные слова различаются по способу использования, но не по способу кодирования;\\n\\t-УУ и АЛУ обычно объединяются в одно, называемое центральным процессором. Они определяют действия путем считывания команд из оперативной памяти. Обработка информации, предписанная алгоритмом, сводится к последовательному выполнению команд в порядке, однозначно определяемом программой.\\n\\tКоманда – совокупность сведений, необходимых процессору для выполнения определенного действия при выполнении программы. Команда состоит из кода операции и нескольких адресных полей, содержащих адреса расположения операндов команды.\\n\\tДля 4-х разрядного процессора эта команда выглядит следующим образом: 0001 0011 1100 1001\\n\\tАЛУ выполняет основную работу по переработке информации, хранимой в ОЗУ. В нем выполняются арифметические и логические операции. Выполняемая функция определяется микрокомандой, получаемой от устройства управления. АЛУ содержит в своем составе устройство, хранящее характеристику результата выполнения операции над данными и называемое флаговым регистром. Отдельные разряды этого регистра указывают на равенство результата нулю, на знак результата операции (+или-), на правильность выполнения операции (наличие переноса за пределы разрядной сетки или переполнения). Программный анализ флага позволяет производить операции ветвления программы в зависимости от конкретных значений данных. Кроме того, в АЛУ имеется набор программно-доступных быстродействующих ячеек памяти, которые называются регистрами процессора. Регистры составляют основу архитектуры процессора. Среди обязательного набора регистров можно отметить следующие. Регистр данных – служит для временного хранения промежуточных результатов при выполнении операций. Регистр- аккумулятор – регистр временного хранения, который используется в процессе вычислений (например, в нем формируется результат выполнения команды умножения). Регистр указатель стека – используется при операциях со стеком, т.е. такой структуры данных, которая работает по принципу: последним вошел -первым вышел, т.е. последнее записанное в него значение извлекается из него первым, стеки используются для организации подпрограмм. Индексные, указательные и базовые регистры используются для хранения и вычисления адресов операндов в памяти. Регистры-счетчики используются для организации циклических участков в программах. Регистры общего назначения, имеющиеся во многих ЭВМ, могут использоваться для любых целей. Точное назначение такого регистра определяет программист при написании программы. Количество регистров и связей между ними оказывает существенное влияние на сложность и стоимость процессора. Однако, с другой стороны, наличие большого количества регистров с богатым набором возможностей упрощает программирование и повышает гибкость программного обеспечения. Кроме перечисленных регистров в состав АЛУ могут входить внутренние системные регистры, не доступные программно и используемые во время внутренних пересылок информации при выполнении команд.\\n\\tУУ. Это часть центрального процессора. УУ вырабатывает распределенную во времени и пространстве последовательность внутренних и внешних управляющих сигналов, обеспечивающих выборку и выполнение команд. На этапе цикла выборки команды УУ интерпретирует команду, выбранную из программной памяти. На этапе выполнения команды в соответствии с типом реализуемой операции УУ формирует требуемый набор команд низкого уровня для АЛУ и других устройств. Эти команды задают последовательность простейших низкоуровневых операций, таких, как пересылка данных, сдвиг данных, установка и анализ признаков, запоминание результатов и др. Такие элементарные низкоуровневые операции называют микрооперациями, а команды, формируемые УУ, называются микрокомандами. Последовательность микрокоманд, соответствующая одной команде, называется микропрограммой.\\n\\tСистема шин. Объединение функциональных блоков в ЭВМ осуществляется посредством следующей системы шин: шины данных, по которой осуществляется обмен информацией между блоками ЭВМ, шины адреса, используемой для передачи адресов (номеров ячеек памяти или портов ввода-вывода, к которым производится обращение), и шины управления для передачи управляющих сигналов. Совокупность этих трех шин называют системной шиной, системной магистралью или системным интерфейсом. Состав и назначение шин, и правило их использования, виды передаваемых по шине сигналов и другие характеристики шины могут существенно различаться у разных видов ЭВМ. Шина состоит из отдельных проводников (линий). Сигналы по линиям шины могут передаваться либо импульсами (наличие импульса соответствует логической 1, а отсутствие импульса-0, либо уровнем напряжения: высокий уровень – логическая 1, низкий - 0). Шириной шины называется количество линий (проводников), входящих в состав шины. Ширина шины адреса определяет размер адресного пространства ЭВМ. Если, например, количество линий адреса, используемых для адресации памяти, равно 20, то общее количество адресуемых ячеек памяти составит 220, т.е. примерно, один миллион ячеек (точнее, 1 048 576).\\n\\tСтруктурой можно описать следующим обобщенным алгоритмом:\\n\\t-Инициализация. После включения ЭВМ или операции сброса в регистры центрального процессора заносятся некоторые начальные значения. Обычно в процессе инициализации в память ЭВМ помещается программа, называемая первичным загрузчиком. Основное назначение первичного занрузчика – загрузить в память с устройства внешней памяти ОС. Эта программа м.б. размещена в энергонезависимом устройстве памяти или автоматически считываться с некоторого устройства внешней памяти. Мы не будем здесь подробно останавливаться на механизмах загрузки ОС, тем более что они могут существенно различаться для разных типов ЭВМ. Пока будем полагать, что в памяти некоторым образом оказалась первая из подлежащих выполнению программ. Программному счетчику присваивается начальное значение, равное адресу первой команды программы, указанной выше.\\n\\t-ЦП производит операцию считывания команды из памяти. В качестве адреса ячейки памяти используется содержимое программного счетчика.\\n\\t-Содержимое считанной ячейки памяти интерпретируется процессором как команда и помещается в регистр команды. УУ приступает к интерпретации прочитанной команды. По полю кода операции из первого слова команды УУ определяет ее длину и, если это необходимо, организует дополнительные операции считывания, пока вся команда полностью не будет прочитана процессором. Вычисленная длина команды прибавляется к исходному содержимому программного счетчика, и когда команда полностью прочитана, программный счетчик будет хранить адрес следующей команды.\\n\\t-По адресным полям команды УУ определяет, имеет ли команда операнды в памяти. Если это так, то на основе указанных в адресных полях режимов адресации вычисляются адреса операндов и производится операция чтения памяти для считывания операндов.\\n\\t-УУ и АЛУ выполняют операцию, указанную в поле кода операции команды. Во флаговом регистре процессора запоминаются признаки результата операции (равно 0 или нет, знак результата, наличие переполнения и т.д.).\\n\\t-Если это необходимо, УУ выполняет операцию записи для того, чтобы поместить результат выполнения команды в память.\\n\\t-Если последняя команда не была командой «остановить процессор», то описанная последовательность действий повторяется, начиная с шага 1. Описанная последовательность действий ЦП с шага 1 до шага 6 называется циклом процессора.\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Регистры. Таймеры\",\n" +
                    "    \"themes\": \"Описание принципов обеспечения работы систем МК и их синхронизация во времени\",\n" +
                    "    \"lessonTextStart\": \"\\tВо время работы МК возникают временные данные, необходимые для работы основной исполняемой программы. Тем не менее некоторые из них логично выделять в особые ячейки памяти — регистры, — поскольку ядро МК обращается к ним с завидной регулярностью. Пожалуй, самым очевидным примером этого является указатель на текущий номер исполняемой программной инструкции. Именно поэтому регистры стоят несколько обособленно от ОЗУ и находятся внутри ядра для упрощения топологии.\\n\\tПосмотрим на регистры на примере микроконтроллера MCS-51 — классического 8-битного микроконтроллера из 80-х гг. Рассматривать будем на таком упрощенном примере, поскольку у STM32 более продвинутая архитектура, и, соответственно, регистры устроены несколько сложнее.\\n\\tМногие из регистров имеют понятное значение. Скажем, регистры TL0, TH0 хранят информацию о счетчике таймера 0. Сразу можем сказать, что счетчик 16-битный. Поговорим про вычислительное ядро. Мы видим, что есть регистры, отвечающие за состояние подсистем, таких как таймеры, за их настройку, как приоритет прерываний. Непосредственно при выполнении операций крайне важен результат, складываемый в аккумулятор ACC + B, и некая его интерпретация, хранящаяся в PSW.\\n\\tПриведем пример — деление целых. Если мы делим 4 на 2, у нас получается просто 2 — ответ будет записан просто в аккумулятор. Если делить 1 024 на 2, получится 512 — ответ будет записан в аккумулятор и расширитель аккумулятора, поскольку целочисленный ответ выходит за размер машинного слова. Если же делить 2 на 0, операция не пройдет. Значение аккумуляторов не изменится, а в слове состояния программы появится код арифметической ошибки.\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"\\tПроцессорное ядро и память микроконтроллеров: версия для печати В этой лекции рассказывается о структуре процессорного ядра и особенностях системы команд микроконтроллеров, функциях и организации памяти программ и данных, об использовании стека и внешней памяти микроконтроллеров\\n\\tОсновной особенностью современного этапа развития МПС является завершение перехода от систем, выполненных на основе нескольких больших ИС, к однокристальным МК, которые объединяют в одном кристалле все основные элементы МПС: центральный процессор (ЦП), постоянное запоминающее устройство (ПЗУ), оперативное запоминающее устройство (ОЗУ), порты ввода/выводы, таймеры.\\n\\tВ настоящее время выпускается целый ряд типов МК. Все эти приборы можно условно разделить на три основных класса:\\n\\t-8-разрядные МК для встраиваемых приложений;\\n\\t-16- и 32-разрядные МК;\\n\\t-цифровые сигнальные процессоры (DSP).\\n\\tНаиболее распространенным представителем семейства МК являются 8-разрядные приборы, широко используемые в промышленности, бытовой и компьютерной технике. Они прошли в своем развитии путь от простейших приборов с относительно слаборазвитой периферией до современных многофункциональных контроллеров, обеспечивающих реализацию сложных алгоритмов управления в реальном масштабе времени. Причиной жизнеспособности 8-разрядных МК является использование их для управления реальными объектами, где применяются, в основном, алгоритмы с преобладанием логических операций, скорость обработки которых практически не зависит от разрядности процессора.\\n\\tПроцессорное ядро включает в себя:\\n\\t-центральный процессор;\\n\\t-внутреннюю контроллерную магистраль (ВКМ) в составе шин адреса, данных и управления;\\n\\t-схему синхронизации МК;\\n\\t-схему управления режимами работы МК, включая поддержку режимов пониженного энергопотребления, начального запуска (сброса) и т.д.\\n\\tИзменяемый функциональный блок включает в себя модули памяти различного типа и объема, порты ввода/вывода, модули тактовых генераторов (Г), таймеры. В относительно простых МК модуль обработки прерываний входит в состав процессорного ядра. В более сложных МК он представляет собой отдельный модуль с развитыми возможностями. В состав изменяемого функционального блока могут входить и такие дополнительные модули как компараторы напряжения, аналого-цифровые преобразователи (АЦП) и другие. Каждый модуль проектируется для работы в составе МК с учетом протокола ВКМ. Данный подход позволяет создавать разнообразные по структуре МК в пределах одного семейства.\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Порты ввода — вывода. Подключение\",\n" +
                    "    \"themes\": \"Описание организации работы с подключаемыми устройствами и правила сопряжения\",\n" +
                    "    \"lessonTextStart\": \"\\tСледующим по важности для функционирования МК являются порты ввода — вывода. Один порт объединяет функции съема сигнала, генерации сигнала и специальных функций из соображений компактности. Рассмотрим структуру порта ввода — вывода. Есть непосредственно физическая ножка — I/O pin, — которая подключена к линиям напряжения логических уровней для защиты от пробития порта.\\n\\tПо линии ввода ножка соединяется с подтягивающими резисторами, которые могут быть включены аппаратно для устранения наводок от случайных шумов. Затем сигнал идет напрямую к аналогово-цифровому преобразователю или через триггер Шмитта в случае, если требуется снять цифровой сигнал.\\n\\tПорты объединяют в блоки для удобства конфигурации через регистры (имеющие длину машинного слова).\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"anything\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Шины связи. Высокоуровневые интерфейсы\",\n" +
                    "    \"themes\": \"Описание работы цифровых шин связи и устройства модулей для работы с подключаемыми устройствами\",\n" +
                    "    \"lessonTextStart\": \"\\tМеханизм формирования цифрового сигнала логичнее всего описывать битом.\\n\\tПри заданном сценарии приема и передачи информации по однобитному порту мы сталкиваемся с низкой скоростью порта. Логичным выходом из данного положения может быть:\\n\\t-Увеличение разрядности самого порта, что, по сути, означает переход к аналоговому сигналу\\n\\t-Увеличение числа портов\\n\\tПервый подход обычно используется в специальной аппаратуре, такой как аудиотехника или аналоговые радиопередатчики. Мы же поговорим о втором подходе. В нем достаточно часто вводится линия синхросигнала, позволяющая сообщить о подготовке данных к считыванию. Это увеличивает как скорость, так и стабильность передачи.\\n\\tИнтерфейсы с синхросигналом называются синхронными. Сигналы с полезной нагрузкой можно разделить на линии передачи данных и адресные линии. Адресные линии выделяются отдельно для достижения максимальной скорости передачи за счет прямого доступа к памяти. Примером такого интерфейса может служить PCI, знакомый многим по домашним МК. В интерфейсах МК, как правило, не встречаются адресные линии. Наиболее распространенные синхронные интерфейсы для МК — I2C и SPI.\\n\\tИспользуются также асинхронные интерфейсы. Самым распространенным является UART, включающий в себя исключительно линию приема и передачи данных. Пакеты данных разделяются передачей стартовой и завершающей последовательностью битов и складываются в буфер приемопередатчика. Ввиду отсутствия синхросигнала важно правильно инициализировать приемопередатчики, поскольку они ожидают получение нового бита с определенной частотой.\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"\\tКомпьютерная шина (computer bus, bidirectional universal switch - двунаправленный универсальный коммутатор) - в архитектуре компьютера подсистема, которая передаёт данные между функциональными блоками компьютера. Обычно шина управляется драйвером. В отличие от связи точка-точка, к шине можно подключить несколько устройств по одному набору проводников. Каждая шина определяет свой набор коннекторов (соединений) для физического подключения устройств, карт и кабелей.\\n\\tРанние компьютерные шины представляли собой параллельные электрические шины с несколькими подключениями, но сейчас данный термин используется для любых физических механизмов, предоставляющих такую же логическую функциональность, как параллельные компьютерные шины. Современные компьютерные шины используют как параллельные, так и последовательные соединения и могут иметь параллельные (multidrop) и цепные (daisy chain) топологии. В случае USB и некоторых других шин могут также использоваться хабы (концентраторы).\\n\\tИспользуемые в статье приставки СИ являются двоичными, а сокращения выполнены в соответствии с ГОСТ 8.417:\\n\\t-1 КБ = 1 024 байт\\n\\t-1 МБ = 1 024 КБ = 1 048 576 байт\\n\\t-1 ГБ = 1 024 МБ = 1 048 576 КБ = 1 073 741 824 байт\\n\\tТак, Ethernet 10 ГБит/с подразумевает что интерфейс может передавать на скоростях до 1010 бит за секунду. для того чтобы посчитать скорость в байт/с, используя бинарные приставки, нужно (1010 / 8) / (1024 * 1024 * 1024) = 1.16415321826934814453125 ГБ/с.\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Прерывания в МК\",\n" +
                    "    \"themes\": \"Объяснение концепции прерываний с примерами из интерфейсов связи\",\n" +
                    "    \"lessonTextStart\": \"anything\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"anything\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Начало работы с STM32\",\n" +
                    "    \"themes\": \"Знакомство с современным МК семейства STM32. Установка IDE и CubeMX\",\n" +
                    "    \"lessonTextStart\": \"anything\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"anything\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Создание проекта и конфигурация МК\",\n" +
                    "    \"themes\": \"Пример создания проекта для STM32 и конфигурации МК под проект\",\n" +
                    "    \"lessonTextStart\": \"anything\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"anything\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Подключение датчиков\",\n" +
                    "    \"themes\": \"Демонстрация работы с датчиками разного типа\",\n" +
                    "    \"lessonTextStart\": \"anything\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"anything\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Управление актуаторами\",\n" +
                    "    \"themes\": \"Рассматриваются аспекты подключения к МК исполнительных систем и математические нюансы\",\n" +
                    "    \"lessonTextStart\": \"anything\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"anything\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Реализация системы управления роботом\",\n" +
                    "    \"themes\": \"Обучающимся предлагается собрать робота на 3D-принтере и оживить его\",\n" +
                    "    \"lessonTextStart\": \"anything\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"anything\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Специальные функции различных серий STM32\",\n" +
                    "    \"themes\": \"Объяснения принципа выбора микроконтроллера для специальных задач\",\n" +
                    "    \"lessonTextStart\": \"anything\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"anything\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"name\": \"Операционные системы для микроконтроллеров\",\n" +
                    "    \"themes\": \"ОС для МК. Основы работы с микроконтроллером под управлением FreeRTOS\",\n" +
                    "    \"lessonTextStart\": \"anything\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"anything\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  }\n" +
                    "]", context = applicationContext
        )
    }
}