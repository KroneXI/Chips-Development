package com.example.chips_development

import android.content.SharedPreferences
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.Fragment
import com.example.chips_development.fragments.*
import com.google.android.material.bottomnavigation.BottomNavigationView
import java.io.FileOutputStream


class MainActivity : AppCompatActivity() {

    private var bottomNavigationMain: BottomNavigationView? = null

    private val testFragment = TestFragment()
    private val studyFragment = StudyFragment()
    private val mainFragment = MainFragment()
    private val shopFragment = ShopsFragment()
    private val aboutFragment = AboutFragment()

    var prefs: SharedPreferences? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        prefs = getSharedPreferences("com.example.chips_development", MODE_PRIVATE);

//        writeFileOnInternalStorage()

        replaceFragment(mainFragment)
        bottomNavigationMain = findViewById(R.id.bottomNavigationMain)

        bottomNavigationMain?.setOnNavigationItemSelectedListener {
            when (it.itemId) {
                R.id.tests -> {
                    replaceFragment(testFragment)
                }
                R.id.study -> {
                    replaceFragment(studyFragment)
                }
                R.id.main -> {
                    replaceFragment(mainFragment)
                }
                R.id.shops -> {
                    replaceFragment(shopFragment)
                }
                R.id.about -> {
                    replaceFragment(aboutFragment)
                }
            }
            true
        }
    }

    override fun onResume() {
        super.onResume()
        if (prefs!!.getBoolean("firstrun", true)) {
            // Do first run stuff here then set 'firstrun' as false
            // using the following line to edit/commit prefs
            prefs!!.edit().putBoolean("firstrun", false).commit()

            writeFileOnInternalStorage(file = "shops.json", data = "[\n" +
                    "  {\n" +
                    "    \"id\": \"1\",\n" +
                    "    \"name\": \"name1\",\n" +
                    "    \"link\": \"https://www.chipdip.ru/\",\n" +
                    "    \"image\": \"https://s.rbk.ru/v1_companies_s3/resized/550xH/media/trademarks/86b2d8ca-8c46-4d25-a8e8-3336c7ade6f1.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"id\": \"2\",\n" +
                    "    \"name\": \"name2\",\n" +
                    "    \"link\": \"https://stackoverflow.com/questions/2201917/how-can-i-open-a-url-in-androids-web-browser-from-my-application\",\n" +
                    "    \"image\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  }\n" +
                    "]")
            writeFileOnInternalStorage(file = "study.json", data = "[\n" +
                    "  {\n" +
                    "    \"id\": \"1\",\n" +
                    "    \"name\": \"Введение\",\n" +
                    "    \"themes\": \"История вычислительной техники. Обзор современных платформ и их приложений\",\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"lessonTextStart\": \"\\tСовременному человеку трудно представить свою жизнь без электронно- вычислительных машин. Влияние вычислительной техники на все сферы деятельности человека продолжает расширяться вширь и вглубь. В настоящее время ЭВМ используются не только для выполнения сложных расчетов, но и в управлении производственными процессами, в образовании, здравоохранении, экологии и т.д. Это объясняется тем, что ЭВМ способны обрабатывать любые виды информации: числовую, текстовую, табличную, графическую, видео, звуковую.\\n\\tИдея использования программного управления для построения устройства, автоматически выполняющего арифметические вычисления, была впервые высказана английским математиком Чарльзом Бэббиджем в1833г. Он начал работать над машиной для вычисления полиномов, но эта машина должна была кроме непосредственного производства вычислений выдавать результаты– печатать их на негативной пластине для фотопечати. Планировалось, что машина будет приводиться в действие паровым двигателем. Но из-за технических трудностей Бэббиджу до конца не удалось реализовать свой проект.\\n\\tВ современном представлении электронная вычислительная машина– это комплекс технических и программных средств для проведения вычислений, а также приёма, переработки, хранения и выдачи информации по заранее определённому алгоритму (компьютерной программе).\\n\\tИнформация – совокупность сведений, знаний, которые актуализируемы (получаемы, передаваемы, преобразуемы, сжимаемы и/или регистрируемы) с помощью некоторых знаков.\\n\\tАлгоритм – это точный набор инструкций, описывающих последовательность действий некоторого исполнителя для достижения результата, решения некоторой задачи.\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"\\tИсторию развития вычислительных машин принято делить на поколения\\n\\t1-е поколение (1945-1954 гг.) — время становления машин с фон-неймановской архитектурой. В этот период формируется типовой набор структурных элементов, входящих в состав ЭВМ. Типичная ЭВМ должна состоять из следующих узлов: центральный процессор(ЦП), оперативная память (или оперативное запоминающее устройство— ОЗУ) и устройства ввода-вывода(УВВ). ЦП, в свою очередь, должен состоять из арифметико-логического устройства(АЛУ) и управляющего устройства(УУ). Машины этого поколения работали на ламповой элементной базе, из-за чего поглощали огромное количество энергии и были очень ненадежны. С их помощью, в основном, решались научные задачи. Программы для этих машин уже можно было составлять не на машинном языке, а на языке ассемблера.\\n\\t2-е поколение (1955-1964 гг.). Смену поколений определило появление новой элементной базы: вместо громоздкой лампы в ЭВМ стали применяться миниатюрные транзисторы, линии задержки как элементы оперативной памяти сменила память на магнитных сердечниках. Это в конечном итоге привело к уменьшению габаритов, повышению надежности и производительности ЭВМ. В архитектуре ЭВМ появились индексные регистры и аппаратные средства для выполнения операций с плавающей точкой. Были разработаны команды для вызова подпрограмм. Появились языки высокого уровня— Algol, FORTRAN, COBOL, — создавшие предпосылки для появления переносимого программного обеспечения, не зависящего от типа ЭВМ. С появлением языков высокого уровня возникли компиляторы для них; библиотеки стандартных подпрограмм и другие хорошо знакомые нам сейчас вещи: Важное новшество— это появление процессоров ввода-вывода. Эти специализированные процессоры позволили освободить ЦП от управления вводом-выводом и осуществлять ввод-вывод с помощью специализированного устройства одновременно с процессом вычислений. Для эффективного управления ресурсами машины стали использоваться операционные системы(ОС).\\n\\t3-е поколение (1965-1970 гг.). Микросхемы позволили разместить десятки элементов на пластине размером в несколько сантиметров. Это, в свою очередь, не только повысило производительность ЭВМ, но и снизило их габариты и стоимость. Увеличение мощности ЭВМ сделало возможным одновременное выполнение нескольких программ на одной ЭВМ. Для этого нужно было научиться координировать между собой одновременно выполняемые действия, для чего были расширены функции операционной системы. Одновременно с активными разработками в области аппаратных и архитектурных решений растет удельный вес разработок в области технологий программирования. В это время активно разрабатываются теоретические основы методов программирования, компиляции, баз данных, операционных систем и т. д. Создаются пакеты прикладных программ для самых различных областей жизнедеятельности человека. Наблюдается тенденция к созданию семейств ЭВМ, то есть машины становятся совместимы снизу в верх на программно-аппаратном уровне. Примерами таких семейств была серия IBM System 360 и наш отечественный аналог- ЕС ЭВМ.\\n\\t4-е поколение (1970-1984 гг.). Очередная смена элементной базы привела к смене поколений. В70-егоды активно ведутся работы по созданию больших и сверхбольших интегральных схем (БИС и СБИС), которые позволили разместить на одном кристалле десятки тысяч элементов. Это повлекло дальнейшее существенное снижение размеров и стоимости ЭВМ. В начале70-хгодов фирмойIntel был выпущен микропроцессор(МП) i4004. И если до этого в мире вычислительной техники были только три направления (суперЭВМ, большие ЭВМ (мэйнфреймы) имини-ЭВМ), то теперь к ним прибавилось еще одно— микропроцессорное.\\n\\t5-е поколение можно назвать микропроцессорным. В1976 году фирма Intel закончила разработку16-разрядногомикропроцессораi8086. Он имел достаточно большую разрядность регистров (16 бит) и системной шины адреса (20 бит), за счет чего мог адресовать до1 Мбайт оперативной памяти. В1982 году был созданi80286. Этот микропроцессор представлял собой улучшенный вариантi8086. Он поддерживал уже несколько режимов работы: реальный, когда формирование адреса производилось по правиламi8086, и защищенный, который аппаратно реализовывал многозадачность и управление виртуальной памятью, i80286 имел также большую разрядность шины адреса— 24 разряда против, 20 уi8086, и поэтому он мог адресовать до16 Мбайт оперативной памяти. Первые компьютеры на базе этого микропроцессора появились в1984 году. В1985 году фирма Intel представила первый32-разрядныймикропроцессорi80386, аппаратно совместимый снизу-вверх со всеми предыдущими микропроцессорами этой фирмы. Он был гораздо мощнее своих предшественников, имел32-разряднуюархитектуру и мог прямо адресовать до 4 Гбайт оперативной памяти. Микропроцессорi386 стал поддерживать новый режим работы— режим виртуальногоi8086, который обеспечил не только большую эффективность работу программ, разработанных дляi8086, но и позволил осуществлять параллельную работу нескольких таких программ.\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  },\n" +
                    "  {\n" +
                    "    \"id\": \"2\",\n" +
                    "    \"name\": \"Введение\",\n" +
                    "    \"themes\": \"История вычислительной техники. Обзор современных платформ и их приложений\",\n" +
                    "    \"check\": \"false\",\n" +
                    "    \"lessonTextStart\": \"\\tСовременному человеку трудно представить свою жизнь без электронно- вычислительных машин. Влияние вычислительной техники на все сферы деятельности человека продолжает расширяться вширь и вглубь. В настоящее время ЭВМ используются не только для выполнения сложных расчетов, но и в управлении производственными процессами, в образовании, здравоохранении, экологии и т.д. Это объясняется тем, что ЭВМ способны обрабатывать любые виды информации: числовую, текстовую, табличную, графическую, видео, звуковую.\\n\\tИдея использования программного управления для построения устройства, автоматически выполняющего арифметические вычисления, была впервые высказана английским математиком Чарльзом Бэббиджем в1833г. Он начал работать над машиной для вычисления полиномов, но эта машина должна была кроме непосредственного производства вычислений выдавать результаты– печатать их на негативной пластине для фотопечати. Планировалось, что машина будет приводиться в действие паровым двигателем. Но из-за технических трудностей Бэббиджу до конца не удалось реализовать свой проект.\\n\\tВ современном представлении электронная вычислительная машина– это комплекс технических и программных средств для проведения вычислений, а также приёма, переработки, хранения и выдачи информации по заранее определённому алгоритму (компьютерной программе).\\n\\tИнформация – совокупность сведений, знаний, которые актуализируемы (получаемы, передаваемы, преобразуемы, сжимаемы и/или регистрируемы) с помощью некоторых знаков.\\n\\tАлгоритм – это точный набор инструкций, описывающих последовательность действий некоторого исполнителя для достижения результата, решения некоторой задачи.\",\n" +
                    "    \"lessonImageStart\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\",\n" +
                    "    \"lessonTextMid\": \"\\tИсторию развития вычислительных машин принято делить на поколения\\n\\t1-е поколение (1945-1954 гг.) — время становления машин с фон-неймановской архитектурой. В этот период формируется типовой набор структурных элементов, входящих в состав ЭВМ. Типичная ЭВМ должна состоять из следующих узлов: центральный процессор(ЦП), оперативная память (или оперативное запоминающее устройство— ОЗУ) и устройства ввода-вывода(УВВ). ЦП, в свою очередь, должен состоять из арифметико-логического устройства(АЛУ) и управляющего устройства(УУ). Машины этого поколения работали на ламповой элементной базе, из-за чего поглощали огромное количество энергии и были очень ненадежны. С их помощью, в основном, решались научные задачи. Программы для этих машин уже можно было составлять не на машинном языке, а на языке ассемблера.\\n\\t2-е поколение (1955-1964 гг.). Смену поколений определило появление новой элементной базы: вместо громоздкой лампы в ЭВМ стали применяться миниатюрные транзисторы, линии задержки как элементы оперативной памяти сменила память на магнитных сердечниках. Это в конечном итоге привело к уменьшению габаритов, повышению надежности и производительности ЭВМ. В архитектуре ЭВМ появились индексные регистры и аппаратные средства для выполнения операций с плавающей точкой. Были разработаны команды для вызова подпрограмм. Появились языки высокого уровня— Algol, FORTRAN, COBOL, — создавшие предпосылки для появления переносимого программного обеспечения, не зависящего от типа ЭВМ. С появлением языков высокого уровня возникли компиляторы для них; библиотеки стандартных подпрограмм и другие хорошо знакомые нам сейчас вещи: Важное новшество— это появление процессоров ввода-вывода. Эти специализированные процессоры позволили освободить ЦП от управления вводом-выводом и осуществлять ввод-вывод с помощью специализированного устройства одновременно с процессом вычислений. Для эффективного управления ресурсами машины стали использоваться операционные системы(ОС).\\n\\t3-е поколение (1965-1970 гг.). Микросхемы позволили разместить десятки элементов на пластине размером в несколько сантиметров. Это, в свою очередь, не только повысило производительность ЭВМ, но и снизило их габариты и стоимость. Увеличение мощности ЭВМ сделало возможным одновременное выполнение нескольких программ на одной ЭВМ. Для этого нужно было научиться координировать между собой одновременно выполняемые действия, для чего были расширены функции операционной системы. Одновременно с активными разработками в области аппаратных и архитектурных решений растет удельный вес разработок в области технологий программирования. В это время активно разрабатываются теоретические основы методов программирования, компиляции, баз данных, операционных систем и т. д. Создаются пакеты прикладных программ для самых различных областей жизнедеятельности человека. Наблюдается тенденция к созданию семейств ЭВМ, то есть машины становятся совместимы снизу в верх на программно-аппаратном уровне. Примерами таких семейств была серия IBM System 360 и наш отечественный аналог- ЕС ЭВМ.\\n\\t4-е поколение (1970-1984 гг.). Очередная смена элементной базы привела к смене поколений. В70-егоды активно ведутся работы по созданию больших и сверхбольших интегральных схем (БИС и СБИС), которые позволили разместить на одном кристалле десятки тысяч элементов. Это повлекло дальнейшее существенное снижение размеров и стоимости ЭВМ. В начале70-хгодов фирмойIntel был выпущен микропроцессор(МП) i4004. И если до этого в мире вычислительной техники были только три направления (суперЭВМ, большие ЭВМ (мэйнфреймы) имини-ЭВМ), то теперь к ним прибавилось еще одно— микропроцессорное.\\n\\t5-е поколение можно назвать микропроцессорным. В1976 году фирма Intel закончила разработку16-разрядногомикропроцессораi8086. Он имел достаточно большую разрядность регистров (16 бит) и системной шины адреса (20 бит), за счет чего мог адресовать до1 Мбайт оперативной памяти. В1982 году был созданi80286. Этот микропроцессор представлял собой улучшенный вариантi8086. Он поддерживал уже несколько режимов работы: реальный, когда формирование адреса производилось по правиламi8086, и защищенный, который аппаратно реализовывал многозадачность и управление виртуальной памятью, i80286 имел также большую разрядность шины адреса— 24 разряда против, 20 уi8086, и поэтому он мог адресовать до16 Мбайт оперативной памяти. Первые компьютеры на базе этого микропроцессора появились в1984 году. В1985 году фирма Intel представила первый32-разрядныймикропроцессорi80386, аппаратно совместимый снизу-вверх со всеми предыдущими микропроцессорами этой фирмы. Он был гораздо мощнее своих предшественников, имел32-разряднуюархитектуру и мог прямо адресовать до 4 Гбайт оперативной памяти. Микропроцессорi386 стал поддерживать новый режим работы— режим виртуальногоi8086, который обеспечил не только большую эффективность работу программ, разработанных дляi8086, но и позволил осуществлять параллельную работу нескольких таких программ.\",\n" +
                    "    \"lessonImageMid\": \"https://thumb.tildacdn.com/tild3730-6439-4131-b461-353766363539/-/resize/600x/-/format/webp/pic_5.jpg\"\n" +
                    "  }\n" +
                    "]")
        }
    }

    private fun replaceFragment(fragment: Fragment) {
        if (fragment != null) {
            val transaction = supportFragmentManager.beginTransaction()
            transaction.replace(R.id.fragmentContainerView, fragment)
            transaction.commit()
        }
    }

    fun writeFileOnInternalStorage(file:String, data:String) {
        val fOut: FileOutputStream = baseContext.openFileOutput(file, MODE_PRIVATE)
        fOut.write(data.toByteArray())
        fOut.close()
    }

//    fun readFileOnInternalStorage(): String {
//        var fileInputStream: FileInputStream? = null
//        fileInputStream = openFileInput("text.txt")
//        val inputStreamReader = InputStreamReader(fileInputStream)
//        val bufferedReader = BufferedReader(inputStreamReader)
//        val stringBuilder: StringBuilder = StringBuilder()
//        var text: String? = null
//        while (run {
//                text = bufferedReader.readLine()
//                text
//            } != null) {
//            stringBuilder.append(text)
//        }
//        return stringBuilder.toString()
//    }

//    fun getJsonDataFromAsset(context: Context, fileName: String, shopList: ArrayList<ShopsItems>) {
//        var input: InputStream? = null
//        try {
//            when (fileName) {
//                "shops.json" -> {
//                    input = context.assets.open(fileName)
//                    val jsonArray = JSONArray(input.bufferedReader().use { it.readText() })
//                    for (i in 0 until jsonArray.length()) {
//                        val jsonObj = jsonArray.getJSONObject(i)
//
//                        shopList.add(
//                            ShopsItems(
//                                shopsName = jsonObj.getString("name"),
//                                shopsLink = jsonObj.getString("link"),
//                                shopsLogo = jsonObj.getString("image")
//                            )
//                        )
//                    }
//                }
//                else -> Toast.makeText(context, "foo", Toast.LENGTH_SHORT).show()
//            }
//        } catch (ioException: IOException) {
//            ioException.printStackTrace()
//        } finally {
//            input?.close()
//        }
//    }
}